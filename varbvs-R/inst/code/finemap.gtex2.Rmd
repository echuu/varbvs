---
title: "Another illustration of Matthew's \"proxy SNP\" idea on GTEx data set"
author: "Peter Carbonetto"
date: October 19, 2017
output:
  html_document:
    theme: readable
    include:
      before_body: include/header.html
      after_body: include/footer.html
---

```{r knitr, echo=FALSE}
knitr::opts_chunk$set(
  comment   = "#",
  results   = "hold",
  collapse  = TRUE,
  fig.align = "center")
```

## Outline

The aim of this analysis is to try out a simple fine-mapping idea.  We
can also build on this analysis to test out other ideas for
fine-mapping (that is, estimating credible sets for the location of
the causal variant near an identified assocation).

## Set up environment

Load a few packages.

```{r}
library(ggplot2)
library(cowplot)
library(varbvs)
```

Also, install the varbvs package from the "finemap" branch on Github.

```{r, eval=FALSE}
library(devtools)
install_github("pcarbo/varbvs",ref = "finemap",subdir = "varbvs-R")
```

## Script parameters

The causal variant should be within the credible set with this
probability.

```{r}
credint.prob <- 0.95
```

For identifying the credible set, compute proxy probabilities for all
SNPs in LD with the target SNP based on this threshold.

```{r}
ld.threshold <- 0.2
```

## Load genotype data

Load the GTEx genotype data for the 4,546 SNPs at ACTN3 locus.

```{r}
load("../datafiles/Thyroid.ENSG00000237846.1Mb.RData")
storage.mode(X) <- "double"
X <- X[,400:1200]
n <- nrow(X)
p <- ncol(X)
```

## Fit variational approximation to posterior

Fit the fully-factorized variational approximation to the posterior
distribution of the coefficients for a linear regression model of a
continuous outcome (quantitiative trait), with spike and slab priors on
the coefficients. 

```{r}
fit <- varbvs(X,Z,y,verbose = FALSE)
```

## Compute proxy probabilities

This function computes the "probability probabilities" assuming that
exactly 1 SNP is causal, then selects the smallest set of SNPs such
that the sum of the proxy probabilities is greater than "pr".

```{r}
get.credible.set <- function (bf, pr) {
  pp      <- bf/sum(bf)
  markers <- order(bf,decreasing = TRUE)
  n       <- min(which(cumsum(pp[markers]) > credint.prob))
  return(markers[1:n])
}
```

## Plot fine-mapping results

To plot the fine-mapping results, I mark the credible SNP sets with
crosses, and coloring the points according to LD with the top 2 SNPs.

```{r, fig.height=20, fig.width=6}
create.finemap.plot <- function (pip, r, markers, plot.title = NULL) {
  clrs <- c("midnightblue","darkviolet","darkorchid","maroon",
            "tomato","orange","gold","yellow")
  dat <- data.frame(pos = 1:p,pip = fit$pip,r = r)
  return(ggplot(mapping = aes(x = pos,y = pip,color = r),
                environment = environment()) +
    geom_point(data = dat,size = 1,shape = 20) +
    geom_point(data = dat[markers,],color = "limegreen",shape = 20,size = 1) +
    scale_x_continuous(breaks = NULL) +
    scale_y_continuous(trans = "log10",breaks = 10^(-4:0)) +
    scale_color_gradientn(colors = clrs,guide = FALSE) +
    labs(x = "",y = "varbvs PIP",title = plot.title) +
    theme_cowplot(font_size = 7) +
    theme(axis.line  = element_blank(),
	      plot.title = element_text(size = 7,face = "plain")))
}
```

Compute the correlations between all the SNPs.

```{r}
R <- cor(X)
```

To test the idea of computing credible SNP sets based on "proxy
probabilities", here I choose the top SNPs by posterior inclusion
probability (PIP), take all candidate SNPs in LD with each of the top
SNPs (based on a pre-specified threshold), then compute the Bayes
factors measuring the improvement in "fit" by using alternative SNPs
instead of the top SNP.

```{r}
top.markers  <- summary(fit,nv = 20)$top.vars
top.markers  <- subset(top.markers,prob > 0.95)
top.markers  <- as.character(top.markers$variable)
cr           <- vector("list",length(top.markers))
plots        <- vector("list",length(top.markers))
names(cr)    <- top.markers
names(plots) <- top.markers
temp <- NULL
for (i in top.markers) {
  vars       <- which(R[,i]^2 >= ld.threshold)
  out        <- varbvsproxybf(X,Z,y,fit,which(colnames(X) == i),vars)
  cr[[i]]    <- vars[get.credible.set(out$BF[,1],credint.prob)]
  j <- names(which.max(out$BF[,1]))
  temp <- c(temp,j)
  plots[[i]] <- create.finemap.plot(fit$pip,abs(R[,j]),cr[[i]],
                                      sprintf("%s (%d)",j,length(cr[[i]])))
}
```

Note that the Bayes factors are computed separately for each
hyperparameter setting. Here, to simplify the example, we just
use the Bayes factors from the first hyperparameter setting
(corresponding to the smallest prior inclusion probability).

```{r}
do.call("plot_grid",c(plots,list(nrow = 6,ncol = 2)))
```
